### The OZ upgrade tool for hardhat defends against 6 kinds of mistakes. What are they and why do they matter?

1. `Initialize`: In Solidity, code that is inside a constructor or part of a global variable declaration is not part of a deployed contract’s runtime bytecode. This code is executed only once, when the contract instance is deployed. As a consequence of this, the code within a logic contract’s constructor will never be executed in the context of the proxy’s state.  When using a contract with the OpenZeppelin Upgrades, you need to change its constructor into a regular function, typically named initialize, where you run all the setup logic, while Solidity ensures that a constructor is called only once in the lifetime of a contract, a regular function can be called many times. To prevent a contract from being initialized multiple times, you need to add a check to ensure the initialize
2. usage of `selfdestruct` opcode and `delegatecall` opcode: If the direct call to the logic contract triggers a selfdestruct operation, then the logic contract will be destroyed, and all your contract instances will end up delegating all calls to an address without any code. This would effectively break all contract instances in your project. A similar effect can be achieved if the logic contract contains a delegatecall operation. If the contract can be made to delegatecall into a malicious contract that contains a selfdestruct, then the calling contract will be destroyed.
3. `Storage collisions` between implementation versions: OpenZeppelin Upgrades detects such collisions and warns the developer appropriately
4. `Unstructured storage proxies`: Instead of storing the _implementation address at the proxy’s first storage slot, it chooses a pseudo random slot instead. This slot is sufficiently random, that the probability of a logic contract declaring a variable at the same slot is negligible. `keccak256('eip1967.proxy.implementation')) - 1` position for implementation contract address. THis will be used for any special storage variable proxy may have. For not those are implementation, beacon and admin addresses. 
5. `Transparent proxies and function clashes` : A transparent proxy will decide which calls are delegated to the underlying logic contract based on the caller address (i.e., the msg.sender):
If the caller is the admin of the proxy (the address with rights to upgrade the proxy), then the proxy will not delegate any calls, and only answer any messages it understands.
If the caller is any other address, the proxy will always delegate a call, no matter if it matches one of the proxy’s functions.
6. `Upgrading` implementation contract mechanism. ??not sure about 6 one